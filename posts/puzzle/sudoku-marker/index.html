<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>数独标记工具 | 简陋的网站</title>

  <link rel="stylesheet" href="/css/root.css">
  <link rel="stylesheet" href="/css/main.css">


    <script src="/js/main.js"></script>


</head>
<body>
  <header>
    <h1>简陋的网站</h1>

  <nav>
    <ul>
    <li>
      <a href="/">首页</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/posts/">发布</a>
    </li>
    <li>
      <a href="/tags/">标签</a>
    </li>
    </ul>
  </nav>


<div class="breadcrumb">
    
    
    
<a href="http://localhost:1313/">首页</a>  >

<a href="http://localhost:1313/posts/">发布</a>  >

<a href="http://localhost:1313/posts/puzzle/sudoku-marker/">数独标记工具</a> 
</div> 

  </header>
  <main>
    
  <h1>数独标记工具</h1>

  
  
  <time datetime="2022-04-03T00:00:00&#43;08:00">April 3, 2022</time>

  <div id="content">
        <style>
        @font-face {
            font-family: Compagnon-Medium;
            src: url('/font/Compagnon-Medium.woff2') format('woff2'),
                 url('/font/Compagnon-Medium.woff') format('woff');
        }
        @font-face {
            font-family: Compagnon-Bold;
            src: url('/font/Compagnon-Bold.woff2') format('woff2'),
                 url('/font/Compagnon-Bold.woff') format('woff');
        }
        @font-face {
            font-family: Compagnon-Roman;
            src: url('/font/Compagnon-Roman.woff2') format('woff2'),
                 url('/font/Compagnon-Roman.woff') format('woff');
        }
        * {margin: 0; padding: 0;}
        #container {width: fit-content; margin: 0 auto; padding: 0; display: flex; flex-direction: column;}
        @media screen and (min-width: 900px) {
            #container {
                flex-direction: row;
            }
        }
        #sudoku {width: 500px; height: 500px; margin-top: 10px; margin-right: 10px;}
        #sudoku canvas {width: 100%; height: 100%;}
        #tool {max-width: 500px;}
        .intro {font-size: smaller; color: var(--second-color); line-height: 1em;}
        button {font-size: 1rem; padding: 0.3rem 0.5rem;}
        /*#color-setter {display: flex; flex-direction: row; justify-content: space-between;}*/
        #background-setter button, #candidate-background-setter button {font-size: 0.7rem;}
        #arrows-list li {list-style: none;}
    </style>

    <script src="/js/pixi.min.js"></script>
    <script src="/js/fontfaceobserver.standalone.js"></script>
    <div id="container">
        <div id="sudoku"></div>
        <div id="tool">
            <div class="intro">单击选中格子，按住ctrl单击可以选择多格。按住alt单击选中候选数。</div>
            <div id="highlight-buttons">高亮：</div>
            <div id="number-buttons">填数：</div>
            <div id="candidate-buttons">候选数：</div>
            <div id="background-setter" style="display: flex; flex-direction: row;">
                <div>
                    <div>格子填色</div>
                    <button data-color="">×</button>
                </div>
                <div>
                    <button data-color="FFC059">ㅤ</button>
                    <button data-color="B1A5F3">ㅤ</button>
                    <button data-color="F7A5A7">ㅤ</button>
                    <button data-color="86E8D0">ㅤ</button>
                    <button data-color="86F280">ㅤ</button>
                    <button data-color="FF7684">ㅤ</button>
                    <button data-color="3FDA65">ㅤ</button>
                    <button data-color="7FBBFF">ㅤ</button>
                    <button data-color="FFA500">ㅤ</button>
                    <br/>
                    <button data-color="F7DE8F">ㅤ</button>
                    <button data-color="DCD4FC">ㅤ</button>
                    <button data-color="FFD2D2">ㅤ</button>
                    <button data-color="CEFBED">ㅤ</button>
                    <button data-color="D7FFD7">ㅤ</button>
                    <button data-color="FFCBCB">ㅤ</button>
                    <button data-color="C5E88E">ㅤ</button>
                    <button data-color="D8B2FF">ㅤ</button>
                </div>
            </div>
            <div id="candidate-background-setter" style="display: flex; flex-direction: row;">
                <div>
                    <div>候选数填色</div>
                    <button data-color="">×</button>
                </div>
                <div>
                    <button data-color="FFC059">ㅤ</button>
                    <button data-color="B1A5F3">ㅤ</button>
                    <button data-color="F7A5A7">ㅤ</button>
                    <button data-color="86E8D0">ㅤ</button>
                    <button data-color="86F280">ㅤ</button>
                    <button data-color="FF7684">ㅤ</button>
                    <button data-color="3FDA65">ㅤ</button>
                    <button data-color="7FBBFF">ㅤ</button>
                    <button data-color="FFA500">ㅤ</button>
                    <br/>
                    <button data-color="F7DE8F">ㅤ</button>
                    <button data-color="DCD4FC">ㅤ</button>
                    <button data-color="FFD2D2">ㅤ</button>
                    <button data-color="CEFBED">ㅤ</button>
                    <button data-color="D7FFD7">ㅤ</button>
                    <button data-color="FFCBCB">ㅤ</button>
                    <button data-color="C5E88E">ㅤ</button>
                    <button data-color="D8B2FF">ㅤ</button>
                </div>
            </div>

            <div class="intro">选中后进入画链模式，先后单击起点和终点即可。按住ctrl：画曲线；按住alt：绿色。</div>
            <input id="arrowing" type="checkbox"><label for="arrowing">画链</label>
            <button id="clean-arrow">×</button>
            <ul id="arrows-list">
            </ul>

            <br/>
            <div>
                <button id="fix-number">固定盘面</button>
                <button id="fill-candidates">自动候选数模式</button>
                <button id="undo">撤销</button>
                <br/>
                <textarea id="sudoku-str" rows="3"></textarea>
                <button id="export">导出</button>
                <button id="import">导入</button>
            </div>
        </div>
    </div>
    <script>
        Set.prototype.get = function(i) {
            let values = this.values();
            for (let j = 0; j < i; j ++) {
                if (values.next().done) {
                    return undefined;
                }
            }
            return values.next().value;
        }
    </script>
    <script>
        function isSingleNumber(str) {
            return str.length === 1 && str >= '1' && str <= '9';
        }
        function canPress(keycode) {
            return (keycode > 47 && keycode < 58) || // number keys
                    // keycode === 32 || keycode === 13 || // spacebar & return key(s) (if you want to allow carriage returns)
                    (keycode > 64 && keycode < 91) || // letter keys
                    (keycode > 95 && keycode < 112) || // numpad keys
                    (keycode > 185 && keycode < 193) || // ;=,-./` (in order)
                    (keycode > 218 && keycode < 223); // [\\]' (in order)
        }
        class Candidate {
            constructor(cell, x, y, radius, number) {
                this.cell = cell;
                this.app = cell.app;
                this.radius = radius;
                this.x = x;
                this.y = y;
                this.size = cell.size / 5;
                this.borderWidth = cell.size / 40;

                let text = new PIXI.Text(String(number));
                text.anchor.x = 0.5;
                text.anchor.y = 0.5;
                text.x = x;
                text.y = y;
                text.zIndex = 200;
                text.style = new PIXI.TextStyle({
                    fontFamily: 'Compagnon-Medium',
                    fontSize: Math.floor(this.size * 1.2),
                    fill: ['#333333'],
                });
                text.alpha = 0;
                this.app.stage.addChild(text);
                this.text = text;

                let background = new PIXI.Graphics();
                background.zIndex = 180;
                background.interactive = true; // 可交互
                background.hitArea = new PIXI.Circle(this.x, this.y, this.radius); // 触发区域
                this.app.stage.addChild(background);
                this.background = background;
                background.on('pointertap', (e) => {
                    this.broadcast(e);
                });
                background.on('pointerdown', (e) => {
                    this.broadcast(e);
                });
                background.on('pointerup', (e) => {
                    this.broadcast(e);
                });
                background.on('pointerover', (e) => {
                    this.broadcast(e);
                });

                let customBackground = new PIXI.Graphics();
                customBackground.zIndex = 190;
                this.app.stage.addChild(customBackground);
                this.customBackground = customBackground;

                let border = new PIXI.Graphics();
                border.lineStyle(this.borderWidth, 0x0099CC, 1);
                border.zIndex = 220;
                border.drawCircle(text.x, text.y, radius);
                border.alpha = 0;
                this.app.stage.addChild(border);
                this.border = border;

                this.has = false;
                this.listeners = [];
            }

            showBorder() {
                this.border.alpha = 1;
            }
            hideBorder() {
                this.border.alpha = 0;
            }

            setCustomBackground(color) {
                this.background.clear();
                if (color !== null) {
                    this.background.beginFill(color);
                    this.background.drawCircle(this.x, this.y, this.radius);
                    this.background.endFill();
                }
            }

            broadcast(e) {
                let res = true;
                if (typeof(e) === 'string') {
                    this.listeners.forEach(l => {
                        if (!l({type: e})) {
                            res = false;
                        }
                    });
                } else {
                    this.listeners.forEach(l => {
                        if (!l(e)) {
                            res = false;
                        }
                    });
                }
                if (res) {
                    this.cell.broadcast(e);
                }
            }

            registerListener(listener) {
                this.listeners.push(listener);
            }
        }
        class Cell {
            constructor(sudoku, r, c, location, blockId) {
                this.sudoku = sudoku;
                this.app = sudoku.app;
                this.size = sudoku.cellSize;

                this.r = r;
                this.c = c;
                this.blockId = blockId;

                this.location = location;

                this.outlineWidth = this.size / 40;
                this.cellBorderWidth = this.size / 20;
                this.candidateSize = this.size / 5;
                this.candidateBorderWidth = this.size / 40;

                let padding = this.size * 3 / 40;
                let candidateMargin = this.size / 20;
                let candidateFullSize = this.candidateSize + this.candidateBorderWidth * 2 + candidateMargin;
                this.candidateLocation = [
                    [padding, padding],
                    [padding + candidateFullSize, padding],
                    [padding + candidateFullSize + candidateFullSize, padding],
                    [padding, padding + candidateFullSize],
                    [padding + candidateFullSize, padding + candidateFullSize],
                    [padding + candidateFullSize + candidateFullSize, padding + candidateFullSize],
                    [padding, padding + candidateFullSize + candidateFullSize],
                    [padding + candidateFullSize, padding + candidateFullSize + candidateFullSize],
                    [padding + candidateFullSize + candidateFullSize, padding + candidateFullSize + candidateFullSize],
                ];

                this.lastInput = null;
                this.lastInputTime = null;

                this.listeners = [];

                this.textStyle = {
                    given: new PIXI.TextStyle({
                        fontFamily: 'Compagnon-Roman',
                        fontSize: this.size,
                        fontWeight: 'bold',
                        fill: ['#000000'],
                    }),
                    value: new PIXI.TextStyle({
                        fontFamily: 'Compagnon-Roman',
                        fontSize: this.size,
                        fontWeight: 'bold',
                        fill: ['#1169EE'],
                    }),
                    note: new PIXI.TextStyle({
                        fontFamily: 'Compagnon-Bold',
                        fontSize: Math.floor(this.size / 2),
                        fontWeight: 'bold',
                        fill: ['#1169EE'],
                        wordWrap: true,
                        wordWrapWidth: this.size,
                        breakWords: true,
                    }),
                };

                // outline
                {
                    let outline = new PIXI.Graphics();
                    outline.lineStyle(this.outlineWidth, 0x000000, 1);
                    outline.drawRect(this.location[0], this.location[1], this.size, this.size);
                    this.app.stage.addChild(outline);
                }

                // Text
                {
                    let text = new PIXI.Text('');
                    text.anchor.x = 0.5;
                    text.anchor.y = 0.5;
                    text.x = this.location[0] + this.size / 2;
                    text.y = this.location[1] + this.size / 2;
                    text.zIndex = 200;
                    this.app.stage.addChild(text);
                    this.text = text;
                }

                // Graphics
                // background
                {
                    let graphics = new PIXI.Graphics();
                    graphics.beginFill(0xFFFFFF);
                    graphics.drawRect(this.location[0], this.location[1], this.size, this.size);
                    graphics.endFill();
                    graphics.zIndex = 100;
                    graphics.interactive = true; // 可交互
                    graphics.buttonMode = true;
                    graphics.hitArea = new PIXI.Rectangle(this.location[0], this.location[1], this.size, this.size); // 触发区域
                    // graphics.on('pointertap', (e) => {
                    //     this.sudoku.cellEvent(this, e);
                    // });
                    graphics.on('pointerdown', (e) => {
                        this.sudoku.cellEvent(this, e);
                    });
                    graphics.on('pointerup', (e) => {
                        this.sudoku.cellEvent(this, e);
                    });
                    graphics.on('pointerover', (e) => {
                        this.sudoku.cellEvent(this, e);
                    });
                    graphics.on('pointerout', (e) => {
                        this.sudoku.cellEvent(this, e);
                    });

                    this.background = graphics;
                    this.app.stage.addChild(graphics);
                }
                // customBackground
                {
                    let customBackground = new PIXI.Graphics();
                    customBackground.zIndex = 110;
                    this.customBackground = customBackground;
                    this.app.stage.addChild(customBackground);
                }
                // border
                {
                    let graphics = new PIXI.Graphics();
                    this.border = graphics;
                    this.border.zIndex = 300;
                    this.border.lineStyle(this.cellBorderWidth, 0x0099CC, 1);
                    let t = this.cellBorderWidth / 2;
                    let lo = [this.location[0]+t, this.location[1]+t, this.location[0]+this.size-t, this.location[1]+this.size-t];
                    this.border.moveTo(this.location[0], lo[1]);
                    this.border.lineTo(this.location[0]+this.size, lo[1]);
                    this.border.moveTo(lo[2], lo[1]);
                    this.border.lineTo(lo[2], lo[3]);
                    this.border.moveTo(this.location[0]+this.size, lo[3]);
                    this.border.lineTo(this.location[0], lo[3]);
                    this.border.moveTo(lo[0], lo[3]);
                    this.border.lineTo(lo[0], lo[1]);
                    this.border.alpha  = 0;
                    this.app.stage.addChild(graphics);
                }

                // candidates
                {
                    this.candidates = [];
                    let radius = this.candidateSize / 2 + this.candidateBorderWidth;
                    for (let i = 0; i < this.sudoku.numTotal; i++) {
                        let clo = this.candidateLocation[i];

                        let candidate = new Candidate(
                            this,
                            this.location[0] + clo[0] + radius,
                            this.location[1] + clo[1] + radius,
                            radius,
                            i + 1,
                        );
                        candidate.registerListener((event) => {
                            return this.sudoku.candidateEvent(candidate, event);
                        });
                        this.candidates.push(candidate);
                    }
                }
            }

            isFixed() {
                return this.text.style === this.textStyle.given;
            }

            onInput(key) {
                if (this.isFixed()) {
                    return;
                }
                let content = this.getContent();
                if (this.sudoku.autoFillCandidatesModel) {
                    if (content.length === 1) {
                        return;
                    }
                    if (!this.candidates[parseInt(key) - 1].has) {
                        return;
                    }
                }

                if (isSingleNumber(key) && this.lastInput === key && Date.now() - this.lastInputTime < 200) {
                    this.setContent(key);
                } else {
                    let index = content.indexOf(key);
                    if (index > -1) {
                        content = content.replace(key, '');
                    } else {
                        content += key;
                    }
                    this.setContent(content);
                }

                this.lastInput = key;
                this.lastInputTime = Date.now();
            }

            getContent() {
                return this.text.text;
            }
            setContent(content) {
                if (this.isFixed()) {
                    return;
                }
                if (content) {
                    this.deleteCandidates();
                }
                if (typeof(content) === 'string') {
                    if (content.length === 1) {
                        this.text.style = this.textStyle.value;
                    } else {
                        this.text.style = this.textStyle.note;
                    }
                    this.text.text = content;
                } else if (typeof(content) === 'object') {

                }
                this.sudoku.cellEvent(this, {type:'change'});
            }
            setGiven(value) {
                if (value) this.text.style = this.textStyle.given;
                this.text.text = value;
            }

            setBackground(color) {
                this.background.clear();
                this.background.beginFill(color);
                this.background.drawRect(this.location[0], this.location[1], this.size, this.size);
                this.background.endFill();
            }

            setCustomBackground(color) {
                this.customBackground.clear();
                if (color !== null) {
                    this.customBackground.beginFill(color);
                    this.customBackground.drawRect(this.location[0], this.location[1], this.size, this.size);
                    this.customBackground.endFill();
                }
            }

            showBorder() {
                this.border.alpha  = 1;
            }

            hideBorder() {
                if (this.border.alpha === 1) {
                    this.broadcast('blur');
                }
                this.border.alpha = 0;
            }

            toggleCandidate(number) {
                if (isSingleNumber(this.getContent())) {
                    return;
                }
                if (this.sudoku.autoFillCandidatesModel) {
                    let visibleCellSet = this.sudoku._visibleCellSet(this);
                    if (Array.from(visibleCellSet).find(cell => cell.getContent() === String(number))) {
                        return;
                    }
                }
                let candidate = this.candidates[number - 1];
                candidate.has = !candidate.has;
                this.renderCandidate(candidate);
            }

            // showCandidates() {
            //     this.candidates.forEach(c => {
            //         this.renderCandidate(c);
            //     });
            // }

            deleteCandidates() {
                this.candidates.forEach(c => {
                    c.has = 0;
                });
                this.renderCandidate();
            }

            // hideCandidates() {
            //     this.candidates.forEach(c => {
            //         c.text.alpha = 0;
            //     });
            // }

            renderCandidate(candidate=null, broadcast=true) {
                if (!candidate) {
                    this.candidates.forEach(c => {
                        this.renderCandidate(c, false);
                    })
                } else if (candidate.has) {
                    candidate.text.alpha = 1;
                } else {
                    candidate.text.alpha = 0;
                }
                if (broadcast) this.broadcast('candidate-change');
            }

            hasCandidate(number) {
                return this.candidates[number - 1].has;
            }

            broadcast(e) {
                if (typeof(e) === 'string') {
                    this.listeners.forEach(l => l({type: e}));
                } else {
                    this.listeners.forEach(l => l(e));
                }
            }

            registerListener(listener) {
                this.listeners.push(listener);
            }
        }

        class Arrow {
            constructor(app, candidate0, candidate1, r, width) {
                this.app = app;
                this.line = null;
                this.triangle = null
                this.width = width;
                this.candidate0 = candidate0;
                this.candidate1 = candidate1;

                let x0 = candidate0.x, y0 = candidate0.y,
                        x1 = candidate1.x, y1 = candidate1.y;
                let dx = x1 - x0, dy = y1 - y0;
                let l = Math.sqrt(dx * dx + dy * dy); // 两个候选数中心的距离
                let xe = dx / l, ye = dy / l; // 单位向量坐标

                // 直线起止点
                this.straight = {};
                this.straight.start = [x0 + r * xe, y0 + r * ye];
                this.straight.end = [x1 - r * xe, y1 - r * ye];
                this.straight.e = [xe, ye];
                this.straight.triangle = this.calTriangle(this.straight.end, this.straight.e, r, r);

                {
                    // 曲线起止点
                    // let dir = 1.047; // 60°
                    let dir = 0.785; // 45°
                    let cos_dir = Math.cos(dir), sin_dir = Math.sin(dir);
                    // 旋转后的单位向量
                    let xer1 = xe * cos_dir - ye * sin_dir;
                    let yer1 = ye * cos_dir + xe * sin_dir;
                    let xer2 = xe * cos_dir + ye * sin_dir;
                    let yer2 = ye * cos_dir - xe * sin_dir;
                    this.curve = {};
                    this.curve.start = [x0 + r * xer1, y0 + r * yer1];
                    this.curve.end = [x1 - r * xer2, y1 - r * yer2];

                }

                {
                    // 曲线控制点
                    // dir = 1.57; // 90°
                    let dir = 1.047; // 60°
                    let cos_dir = Math.cos(dir), sin_dir = Math.sin(dir);
                    // 旋转后的单位向量
                    let xer1 = xe * cos_dir - ye * sin_dir;
                    let yer1 = ye * cos_dir + xe * sin_dir;
                    let xer2 = xe * cos_dir + ye * sin_dir;
                    let yer2 = ye * cos_dir - xe * sin_dir;
                    this.curve.ctrlPoint = [
                        [this.curve.start[0] + r * xer1, this.curve.start[1] + r * yer1],
                        [this.curve.end[0] - r * xer2, this.curve.end[1] - r * yer2]
                    ];
                }

                {
                    // 头
                    let dir = 0.523 / l * 60; // 30°
                    let cos_dir = Math.cos(dir), sin_dir = Math.sin(dir);
                    // 旋转后的单位向量
                    // let xer1 = xe * cos_dir - ye * sin_dir;
                    // let yer1 = ye * cos_dir + xe * sin_dir;
                    let xer2 = xe * cos_dir + ye * sin_dir;
                    let yer2 = ye * cos_dir - xe * sin_dir;
                    this.curve.triangle = this.calTriangle(this.curve.end, [xer2, yer2], r, r); // 箭头
                }
            }
            calTriangle(top, e, height, width) {
                // 箭头（等腰三角）
                let x2 = top[0], y2 = top[1]; // line的终点就是顶点
                let xe = e[0], ye = e[1];
                let xv = x2 - height * xe, yv = y2 - height * ye; // 垂点（高为r）
                let xe2 = xe * xe, ye2 = ye * ye;
                let xbe = - ye / Math.sqrt((xe2 + ye2)), ybe = xe / Math.sqrt((xe2 + ye2)); // 底的单位向量（底长为r）
                let bdx = width/2 * xbe, bdy = width/2 * ybe;
                return [
                    [x2, y2],
                    [xv + bdx, yv + bdy],
                    [xv - bdx, yv - bdy]
                ];
            }
            draw(curve = false, strong = true) {
                if (this.line !== null) return;
                // 画线
                let line = new PIXI.Graphics();
                line.lineStyle(this.width, strong ? 0xFF0000 : 0x33CC33, 1);
                line.zIndex = 300;
                if (curve) {
                    line.moveTo(this.curve.start[0], this.curve.start[1]);
                    line.bezierCurveTo(
                            this.curve.ctrlPoint[0][0], this.curve.ctrlPoint[0][1],
                            this.curve.ctrlPoint[1][0], this.curve.ctrlPoint[1][1],
                            this.curve.end[0], this.curve.end[1]);
                } else {
                    line.moveTo(this.straight.start[0], this.straight.start[1]);
                    line.lineTo(this.straight.end[0], this.straight.end[1]);
                }
                this.line = line;
                this.app.stage.addChild(line);

                // 画三角
                let triangle = new PIXI.Graphics();
                triangle.beginFill(strong ? 0xFF0000 : 0x33CC33);
                if (curve) {
                    triangle.drawPolygon(
                            this.curve.triangle[0][0], this.curve.triangle[0][1],
                            this.curve.triangle[1][0], this.curve.triangle[1][1],
                            this.curve.triangle[2][0], this.curve.triangle[2][1],
                    );
                } else {
                    triangle.drawPolygon(
                            this.straight.triangle[0][0], this.straight.triangle[0][1],
                            this.straight.triangle[1][0], this.straight.triangle[1][1],
                            this.straight.triangle[2][0], this.straight.triangle[2][1],
                    );
                }
                triangle.endFill();
                triangle.zIndex = 300;
                this.triangle = triangle;
                this.app.stage.addChild(triangle);
            }
            clean() {
                if (this.line !== null) {
                    this.app.stage.removeChild(this.line);
                    this.line = null;
                }
                if (this.triangle != null) {
                    this.app.stage.removeChild(this.triangle);
                    this.triangle = null;
                }
            }
        }
        class Sudoku {
            constructor(element, numTotal, blockSize/*[宫内列数,宫内行数]*/, cellSize) {
                this.element = element;
                this.numTotal = numTotal;
                this.block = null;
                if (blockSize) {
                    if (blockSize[0] * blockSize[1] !== numTotal) {
                        alert('blockSize错误');
                        return;
                    }
                    this.block = [blockSize[1], blockSize[0]]; // [一行有几个宫，一列有几个宫]
                }
                this.rMax = numTotal - 1;
                this.cMax = numTotal - 1;

                this.data = [];
                this.logs = [];
                this.changed = false;

                this.cellSize = cellSize;
                this.borderWidth = cellSize / 40;
                this.bigBorderWidth = this.borderWidth * 3;
                this.sudokuSize = [
                    cellSize * numTotal + this.borderWidth * numTotal + this.bigBorderWidth, // width
                    cellSize * numTotal + this.borderWidth * numTotal + this.bigBorderWidth // height
                ]
                this.outline = (this.bigBorderWidth + this.borderWidth) / 2;

                this.app = null;
                this.cells = [
                    [null,null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null,null],
                ];

                this.activeCells = new Set;
                this.activeCandidates = new Set;
                this.selecting = false;
                this.deselecting = false;
                this.candidateSelecting = false;
                this.candidateDeselecting = false;
                this.ctrling = false;
                this.alting = false;

                this.arrowLineWidth = this.cellSize / 40;
                this.arrows = [];
                this.arrowing = false;
            }

            init() {
                this.initData();

                return new Promise((resolve) => {
                    this.initCanvas().then(() => {
                        this.logNow(true);
                        resolve(this);
                    });
                });
            }

            // 初始化数独数据
            initData(str = '') {
                // this.data = [];
                // this.log = [];
                // str = str.trim();
                // if (str && str.length === 81) {
                //     for (let r = 0; r <= this.rMax; r ++) {
                //         let row = [];
                //         for (let c = 0; c <= this.cMax; c ++) {
                //             let value = str[r * 9 + c];
                //             if (value >= '1' && value <= '9') {
                //                 row.push({value:value,candidates:[null,null,null,null,null,null,null,null,null,null],fix:value,cage:null});
                //             } else {
                //                 row.push({value:null,candidates:[null,null,null,null,null,null,null,null,null,null],fix:value,cage:null});
                //             }
                //         }
                //         this.data.push(row);
                //     }
                // } else {
                //     for (let r = 0; r <= this.rMax; r++) {
                //         let row = [];
                //         for (let c = 0; c <= this.cMax; c++) {
                //             row.push({value:null,candidates:[null,null,null,null,null,null,null,null,null,null],fix:false,cage:null});
                //         }
                //         this.data.push(row);
                //     }
                // }

                // this.data[0][0].cage = {id:1,sum:13}
                // this.data[0][1].cage = {id:1,sum:13}
                // this.data[1][1].cage = {id:1,sum:13}
                // this.data[1][0].cage = {id:2,sum:22}
                // this.data[2][0].cage = {id:2,sum:22}
                // this.data[2][1].cage = {id:2,sum:22}
            }

            // 初始化canvas
            initCanvas() {
                return new Promise((resolve) => {
                    new FontFaceObserver('Compagnon-Medium', {}).load().then(() => {
                        new FontFaceObserver('Compagnon-Bold', {}).load().then(() => {
                            new FontFaceObserver('Compagnon-Roman', {}).load().then(() => {
                                this.app = new PIXI.Application({
                                    width: this.sudokuSize[0],
                                    height: this.sudokuSize[1],
                                    // resolution: 2,
                                });
                                this.element.appendChild(this.app.view);
                                this.app.renderer.background.color = 0xFFFFFF;
                                this.app.stage.sortableChildren = true;

                                this.setEventListener();
                                this.drawCellOutline();
                                resolve();
                            }, () => {
                                console.error('Unable to load required font!');
                            });
                        }, () => {
                            console.error('Unable to load required font!');
                        });
                    }, () => {
                        console.error('Unable to load required font!');
                    });
                });
            }

            setEventListener() {
                this.element.addEventListener('click', (event) => {
                    event.stopPropagation();
                });
                this.element.addEventListener('mouseout', () => {
                    this.selecting = false;
                });
                this.element.addEventListener('mouseup', () => {
                    this.selecting = false;
                });
                this.element.addEventListener('touchend', () => {
                    this.selecting = false;
                });
                // window.document.addEventListener('keypress', (e) => {
                //     console.log('keypress', e)
                // });
                window.document.addEventListener('keydown', (e) => {
                    // console.log(e)
                    if (e.ctrlKey) {
                        if (e.key === 'Control') {
                            this.ctrling = true;
                        } else if (e.key === 'z') {
                            this.undo();
                        } else if (isSingleNumber(e.key)) {
                            this.onKeypress(e.key, true);
                            e.preventDefault(); // 组织浏览器自带的快捷键
                        }
                    }
                    if (e.altKey) {
                        if (e.key === 'Alt') {
                            this.alting = true;
                        }
                    }
                    if (e.ctrlKey || e.altKey) {return;}
                    if (canPress(e.keyCode)) {
                        this.onKeypress(e.key, false);
                    } else if (e.key === 'Delete') {
                        if (this.autoFillCandidatesModel) return; // 自动候选数模式下请通过撤销删去错误填数
                        this.cleanActiveCellsContent();
                    } else if (e.key === 'ArrowRight') {
                        if (this.activeCells.size === 1) {
                            let cell = this.activeCells.get(0);
                            if (cell.c + 1 <= this.numTotal) {
                                this.setActiveCell(this.cells[cell.r-1][cell.c]);
                            }
                        }
                    } else if (e.key === 'ArrowLeft') {
                        if (this.activeCells.size === 1) {
                            let cell = this.activeCells.get(0);
                            if (cell.c - 1 >= 1) {
                                this.setActiveCell(this.cells[cell.r-1][cell.c-2]);
                            }
                        }
                    } else if (e.key === 'ArrowDown') {
                        if (this.activeCells.size === 1) {
                            let cell = this.activeCells.get(0);
                            if (cell.r + 1 <= this.numTotal) {
                                this.setActiveCell(this.cells[cell.r][cell.c-1]);
                            }
                        }
                    } else if (e.key === 'ArrowUp') {
                        if (this.activeCells.size === 1) {
                            let cell = this.activeCells.get(0);
                            if (cell.r - 1 >= 1) {
                                this.setActiveCell(this.cells[cell.r-2][cell.c-1]);
                            }
                        }
                    } else if (e.key === 'Escape') {
                        if (this.activeCells.size > 0) {
                            this.setActiveCell(null);
                            this.highlight(null);
                        }
                        if (this.activeCandidates.size > 0) {
                            this.setActiveCandidate(null);
                        }
                    }
                });
                window.document.addEventListener('keyup', (e) => {
                    if (e.key === 'Control') {
                        this.ctrling = false;
                    } else if (e.key === 'Alt') {
                        this.alting = false;
                    }
                });
                window.onblur = () => {
                    this.ctrling = false;
                    this.alting = false;
                    this.selecting = false;
                    this.deselecting = false;
                    this.candidateSelecting = false;
                    this.candidateDeselecting = false;
                }
            }

            onKeypress(key, ctrlKey=false) {
                let singleNumber = isSingleNumber(key);
                if (this.autoFillCandidatesModel && !singleNumber) {
                    return;
                }
                if (ctrlKey && singleNumber) {
                    if (this.activeCells.size > 0) {
                        this.activeCells.forEach(cell => {
                            cell.toggleCandidate(parseInt(key));
                        });
                    }
                    return;
                }
                if (this.activeCells.size > 0) {
                    this.activeCells.forEach(cell => {
                        cell.onInput(key);
                    });
                }
            }

            cleanActiveCellsContent() {
                if (this.autoFillCandidatesModel) {return;}
                if (this.activeCells.size > 0) {
                    this.activeCells.forEach(cell => {
                        cell.setContent('');
                    });
                }
            }

            // 画边框和格子
            drawCellOutline() {
                let app = this.app;

                if (this.block) {
                    let graphics = new PIXI.Graphics();
                    graphics.zIndex = 105;
                    graphics.lineStyle(this.bigBorderWidth, 0x000000, 1)
                    for (let c = 1; c <= this.numTotal+1; c += this.block[0]) {
                        let xLocation = this._getXLocation(c) - this.borderWidth / 2;
                        graphics.moveTo(xLocation, 0);
                        graphics.lineTo(xLocation, this.sudokuSize[1]);
                    }
                    for (let r = 1; r <= this.numTotal+1; r += this.block[1]) {
                        let yLocation = this._getYLocation(r) - this.borderWidth / 2;
                        graphics.moveTo(0, yLocation);
                        graphics.lineTo(this.sudokuSize[0], yLocation);
                    }
                    app.stage.addChild(graphics);
                }

                // cell 格子
                for (let r = 1; r <= this.numTotal; r ++) {
                    for (let c = 1; c <= this.numTotal; c ++) {
                        let cell = new Cell(this, r, c, this._getCellLocation(r, c), this._getBlockId(r,c));
                        cell.registerListener((event) => {this.cellEvent(cell, event);});
                        this.cells[r-1][c-1] = cell;
                    }
                }
            }

            // 得到格子左上角坐标
            _getCellLocation(r, c) {
                return [this._getXLocation(c), this._getYLocation(r)];
            }
            _getXLocation(c) {
                return this.outline + (this.cellSize+this.borderWidth)*(c-1);
            }
            _getYLocation(r) {
                return this.outline + (this.cellSize+this.borderWidth)*(r-1)
            }

            _getBlockId(r, c) {
                if (this.block) {
                    let carry = this.numTotal / this.block[0];
                    return Math.floor((r-1) / this.block[0]) * carry + Math.floor((c-1) / this.block[1]);
                } else {
                    // TODO 还不支持变形数独
                    return 0;
                }
           }

            eachCell(fun) {
                for (let r = 0; r <= this.rMax; r ++) {
                    let row = this.cells[r];
                    for (let c = 0; c <= this.cMax; c ++) {
                        fun(row[c])
                    }
                }
            }

            getActiveCell() {
                return this.activeCells;
            }
            setActiveCell(cell) {
                this.activeCells.forEach((c) => {
                    c.hideBorder();
                });
                this.activeCells = new Set([]);
                this.addActiveCell(cell);
            }
            addActiveCell(cell) {
                if (!cell) return;
                this.activeCells.add(cell);
                cell.showBorder();
            }
            removeActiveCell(cell) {
                this.activeCells.delete(cell);
                cell.hideBorder();
            }
            getActiveCandidates() {
                return this.activeCandidates;
            }
            setActiveCandidate(candidate) {
                this.activeCandidates.forEach((c) => {
                    c.hideBorder();
                });
                this.activeCandidates = new Set([]);
                this.addActiveCandidate(candidate);
            }
            addActiveCandidate(candidate) {
                if (!candidate) return;
                this.activeCandidates.add(candidate);
                candidate.showBorder();
            }
            removeActiveCandidate(candidate) {
                this.activeCandidates.delete(candidate);
                candidate.hideBorder();
            }

            highlight(number) {
                this.highlightNum = number;
                this.eachCell((cell) => {
                    cell.setBackground(0xFFFFFF);
                    this.highlightCell(cell);
                });
            }

            highlightCell(cell) {
                if (this.highlightNum) {
                    let content = cell.text.text;
                    if (content) {
                        if (content.length === 1 && content === this.highlightNum) {
                            cell.setBackground(0xFFFF99);
                        } else if (content.includes(this.highlightNum)) {
                            cell.setBackground(0xFFFFCC);
                        } else {
                            cell.setBackground(0xFFFFFF);
                        }
                    } else if (cell.hasCandidate(parseInt(this.highlightNum))) {
                        cell.setBackground(0xFFFFCC);
                    } else {
                        cell.setBackground(0xFFFFFF);
                    }
                } else {
                    cell.setBackground(0xFFFFFF);
                }
            }

            startAutoFillCandidatesModel() {
                if (this.autoFillCandidatesModel) return;
                this.logNow();
                this.autoFillCandidatesModel = true;
                this._fillCandidates();
            }

            _fillCandidates() {
                this.eachCell(cell => {
                    let content = cell.getContent();
                    if (/^[1-9]$/.test(content)) {
                        cell.candidates.forEach((candidate) => {
                            candidate.has = false;
                        });
                    } else if (/^[1-9]{2,}$/.test(content)) { // TODO 支持16进制
                        cell.candidates.forEach((candidate, i) => {
                            candidate.has = !!content.includes(String(i + 1));
                        });
                        cell.setContent('');
                    } else { // 重新计算候选数
                        let set = new Set(); // 所有看到的格子中已填过的数
                        let cellSet = this._visibleCellSet(cell);
                        cellSet.forEach(c => {
                            let content = c.getContent();
                            if (content.length === 1) {
                                set.add(content);
                            }
                        });
                        cell.candidates.forEach((candidate, i) => {
                            candidate.has = !set.has(String(i + 1));
                        });
                        cell.setContent('');
                    }
                    cell.renderCandidate();
                });
                this.logNow();
            }

            // 能看到的格子
            _visibleCellSet(cell) {
                let set = new Set();
                // 同行
                this.cells[cell.r - 1].forEach(c => {
                    set.add(c);
                });
                // 同列
                this.cells.forEach(row => {
                    set.add(row[cell.c - 1]);
                });
                // 同宫
                this.cells.forEach(row => {
                    row.filter(c => c.blockId === cell.blockId).forEach(c => {
                        set.add(c);
                    });
                });
                return set;
            }

            cellEvent(cell, event) {
                // console.log('cell event', cell.location, event.type)
                switch (event.type) {
                    // case 'click':
                    // case 'tap':
                    //     if (!this.ctrling) {
                    //         // this.setActiveCell(cell);
                    //         if (cell.text.text.length === 1) {
                    //             this.highlight(cell.text.text);
                    //         }
                    //     }
                    //     break;
                    case 'pointerdown':
                        // console.log(event.button)
                        if (event.button === 0) { // 左键
                            if (this.ctrling) {
                                if (this.activeCells.has(cell)) {
                                    this.removeActiveCell(cell);
                                    this.deselecting = true;
                                } else {
                                    this.addActiveCell(cell);
                                    this.selecting = true;
                                }
                            } else {
                                this.setActiveCell(cell);
                                this.selecting = true;
                            }
                        }
                        break;
                    case 'pointerup':
                        this.selecting = false;
                        this.deselecting = false;
                        break;
                    case 'pointerover':
                        if (this.selecting) {
                            this.addActiveCell(cell);
                        } else if (this.deselecting) {
                            this.removeActiveCell(cell);
                        }
                        break;
                    case 'change':
                        this.highlightCell(cell);
                        this.changed = true;
                        let content = cell.getContent();
                        if (this.autoFillCandidatesModel && content.length === 1 && content >= '1' &&  content <= '9') {
                            content = parseInt(content);
                            // 自动更新候选数
                            let visibleCellSet = this._visibleCellSet(cell);
                            visibleCellSet.forEach(cell => {
                                let candidate = cell.candidates[content - 1];
                                candidate.has = false;
                                cell.renderCandidate(candidate);
                            });
                        }
                        break;
                    case 'candidate-change':
                        this.highlightCell(cell);
                        this.changed = true;
                        break;
                    case 'blur':
                        this.logNow();
                        break;
                }
            }

            candidateEvent(candidate, event) {
                // console.log(candidate, event);
                switch (event.type) {
                    case 'pointerdown':
                        if (event.button === 0) { // 左键
                            if (this.arrowing) {
                                if (this.activeCandidates.size !== 1) {
                                    this.setActiveCandidate(candidate);
                                } else {
                                    this.drawArrow(this.activeCandidates.get(0), candidate, this.ctrling, !this.alting);
                                    this.setActiveCandidate(null);
                                }
                                return false;
                            }
                            if (this.alting) {
                                if (this.ctrling) {
                                    if (this.activeCandidates.has(candidate)) {
                                        this.removeActiveCandidate(candidate);
                                        this.candidateDeselecting = true;
                                    } else {
                                        this.addActiveCandidate(candidate);
                                        this.candidateSelecting = true;
                                    }
                                } else {
                                    this.setActiveCandidate(candidate);
                                    this.candidateSelecting = true;
                                }
                                return false;
                            }
                        }
                        break;
                    case 'pointerup':
                        this.candidateSelecting = false;
                        this.candidateDeselecting = false;
                        break;
                    case 'pointerover':
                        if (this.alting) {
                            if (this.candidateSelecting) {
                                this.addActiveCandidate(candidate);
                            } else if (this.candidateDeselecting) {
                                this.removeActiveCandidate(candidate);
                            }
                            return false;
                        }
                        break;
                }
                return true; // 向父元素（cell）传递事件
            }

            drawArrow(candidate0, candidate1, curve=false, strong=true) {
                let index = this.arrows.findIndex(a => a.candidate0===candidate0&&a.candidate1===candidate1);
                if (index >= 0) {
                    this.arrows[index].clean();
                    this.arrows.splice(index, 1);
                } else {
                    let arrow = new Arrow(this.app, candidate0, candidate1, candidate0.radius, this.arrowLineWidth);
                    arrow.draw(curve, strong);
                    this.arrows.push(arrow);
                }
            }

            cleanArrow() {
                this.arrows.forEach(a => {
                    a.clean();
                });
                this.arrows = [];
            }

            fixNumber() {
                for (let i in this.cells) {
                    let row = this.cells[i];
                    for (let j in row) {
                        let cell = row[j];
                        if (cell.text.text && cell.text.text.length === 1) {
                            cell.text.style = cell.textStyle.given;
                        }
                    }
                }
                this.logs = [];
                this.logNow();
            }

            toString() {
                let str = '';
                for (let i in this.cells) {
                    let row = this.cells[i];
                    for (let j in row) {
                        let cell = row[j];
                        let value = cell.text.text;
                        if (value && value.length === 1) {
                            str += value;
                        } else {
                            str += '.';
                        }
                    }
                }
                return str;
            }

            fromString(str) {
                if (str.length === 81) {
                    for (let r = 0; r <= this.rMax; r ++) {
                        let row = this.cells[r];
                        for (let c = 0; c <= this.cMax; c ++) {
                            let value = str[r * 9 + c];
                            if (value >= '1' && value <= '9') {
                                row[c].setGiven(value);
                            } else {
                                row[c].setGiven('');
                            }
                        }
                    }
                }
            }

            logNow(force = false) {
                if (!force && !this.changed) return;
                this.changed = false;

                let cells = [];
                this.eachCell(cell => {
                    let candidates = [];
                    cell.candidates.forEach(candidate => {
                        candidates.push({
                            has: candidate.has,
                            show: candidate.text.alpha === 1,
                        });
                    });
                    cells.push({
                        text: cell.text.text,
                        style: cell.text.style,
                        candidates: candidates,
                    });
                });
                console.log('log now')
                this.logs.push({cells: cells, autoFillCandidatesModel: this.autoFillCandidatesModel});
            }

            undo() {
                this.logNow(); // 先保存最后一步
                if (this.logs.length === 1) return;
                this.logs.pop();
                let log = this.logs[this.logs.length - 1];
                let i = 0;
                this.eachCell((cell) => {
                    let cellInfo = log.cells[i++];
                    cell.text.text = cellInfo.text;
                    cell.text.style = cellInfo.style;
                    cell.candidates.forEach((candidate, j) => {
                        candidate.text.alpha = cellInfo.candidates[j].show;
                        candidate.has = cellInfo.candidates[j].has;
                    });
                });
                this.autoFillCandidatesModel = log.autoFillCandidatesModel;
                this.highlight(null);
            }
        }

        let sudoku = new Sudoku(window.document.getElementById('sudoku'), 9, [3,3], 80);

        window.document.body.addEventListener('click', () => {
            sudoku.setActiveCell(null);
        });

        window.document.getElementById('fix-number').addEventListener('click', () => {
            sudoku.fixNumber();
        });
        window.document.getElementById('fill-candidates').addEventListener('click', (event) => {
            event.stopPropagation();
            sudoku.startAutoFillCandidatesModel();
        });

        window.document.getElementById('export').addEventListener('click', () => {
            window.document.getElementById('sudoku-str').value = sudoku.toString();
        });
        window.document.getElementById('import').addEventListener('click', () => {
            sudoku.fromString(window.document.getElementById('sudoku-str').value);
        });
        window.document.getElementById('undo').addEventListener('click', () => {
            sudoku.undo();
        });

        // 高亮、填数、候选数按钮
        let highlightButtons = window.document.getElementById('highlight-buttons');
        highlightButtons.addEventListener('click', (event) => {event.stopPropagation();});
        let numberButtons = window.document.getElementById('number-buttons');
        numberButtons.addEventListener('click', (event) => {event.stopPropagation();});
        let candidateButtons = window.document.getElementById('candidate-buttons');
        candidateButtons.addEventListener('click', (event) => {event.stopPropagation();});
        for (let i = 1; i <= sudoku.numTotal; i++) {
            let button0 = window.document.createElement('button');
            button0.innerText = String(i);
            button0.onclick = () => {sudoku.highlight(i);};
            highlightButtons.appendChild(button0);
            let button1 = window.document.createElement('button');
            button1.innerText = String(i);
            button1.onclick = () => {sudoku.onKeypress(String(i));};
            numberButtons.appendChild(button1);
            let button2 = window.document.createElement('button');
            button2.innerText = String(i);
            button2.onclick = () => {sudoku.onKeypress(String(i), true);};
            candidateButtons.appendChild(button2);
        }
        {
            let button0 = window.document.createElement('button');
            button0.innerText = 'x';
            button0.onclick = () => {sudoku.highlight(null);};
            highlightButtons.appendChild(button0);
            let button1 = window.document.createElement('button');
            button1.innerText = 'x';
            button1.onclick = () => {sudoku.cleanActiveCellsContent();};
            numberButtons.appendChild(button1);
        }

        // 填色按钮
        let backgroundSetter = window.document.getElementById('background-setter');
        backgroundSetter.addEventListener('click', (event) => {
            event.stopPropagation();
        });
        let buttons = backgroundSetter.querySelectorAll('button');
        buttons.forEach(button => {
            let color = button.getAttribute('data-color');
            if (color) {
                button.style.backgroundColor = '#' + color;
                button.addEventListener('click', () => {
                    sudoku.getActiveCell().forEach(cell => {
                        cell.setCustomBackground(Number('0x' + color));
                    });
                });
            } else {
                button.addEventListener('click', () => {
                    sudoku.eachCell(cell => {
                        cell.setCustomBackground(null);
                    });
                });
            }
        });
        let candidateBackgroundSetter = window.document.getElementById('candidate-background-setter');
        candidateBackgroundSetter.addEventListener('click', (event) => {
            event.stopPropagation();
        });
        let candidateBackgroundButtons = candidateBackgroundSetter.querySelectorAll('button');
        candidateBackgroundButtons.forEach(button => {
            let color = button.getAttribute('data-color');
            if (color) {
                button.style.backgroundColor = '#' + color;
                button.addEventListener('click', () => {
                    sudoku.getActiveCandidates().forEach(candidate => {
                        candidate.setCustomBackground(Number('0x' + color));
                    });
                });
            } else {
                button.addEventListener('click', () => {
                    sudoku.eachCell(cell => {
                        cell.candidates.forEach(c => c.setCustomBackground(null));
                    });
                });
            }
        });

        const arrowingInput = window.document.getElementById('arrowing')
        arrowingInput.addEventListener('click', function() {
            sudoku.arrowing = arrowingInput.checked;
        });
        window.document.getElementById('clean-arrow').addEventListener('click', function() {
            sudoku.cleanArrow();
        });

        window.document.body.onselectstart  = function () {return false;}

        sudoku.init().then((sudoku) => {
            // console.log(sudoku);
            // let c0 = sudoku.cells[0][0].candidates[0];
            // let c1 = sudoku.cells[5][5].candidates[0];
            // sudoku.drawArrow(c0, c1);
            // c0 = sudoku.cells[3][4].candidates[0];
            // c1 = sudoku.cells[1][3].candidates[0];
            // sudoku.drawArrow(c0, c1, true);
            // c0 = sudoku.cells[8][6].candidates[0];
            // c1 = sudoku.cells[7][8].candidates[0];
            // sudoku.drawArrow(c0, c1);
            // c0 = sudoku.cells[7][7].candidates[0];
            // c1 = sudoku.cells[8][5].candidates[0];
            // sudoku.drawArrow(c0, c1, true);
        });

      </script>

  </div>
  
  <div class="tags">
    <div>标签:</div>
    <ul>
        <li><a href="/tags/%E8%A7%A3%E8%B0%9C/">解谜</a></li>
    </ul>
  </div>


  </main>
  <footer>
    <p>Copyright 2024. All rights reserved.</p>

  </footer>
</body>
</html>
